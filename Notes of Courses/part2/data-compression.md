# 数据压缩

## introduction

压缩数据可以节省存储数据需要的空间和传输数据需要的时间，虽然摩尔定律说集成芯片上的晶体管每 18-24 个月翻一倍，帕金森定律说数据会自己拓展来填满可用空间，但数据压缩还是最经济的做法。

数据压缩的基本模型如下，很简单，压缩和解压，压缩率即 C(B) 和 B 的比特数之比。

![data-compression-basic-model](https://images2018.cnblogs.com/blog/886021/201808/886021-20180822110449150-737198093.png)

数据压缩的对象本质上是二进制文件，抽象层次是比特流，所以有必要贴下课程里怎么读写二进制文件。

![binary-stdin](https://images2018.cnblogs.com/blog/886021/201808/886021-20180822110503390-1412213682.png)

大多数系统的输入输出系统，像 Java，是基于 8 位的字节流，上面输入的数据可以不用和字节边界对齐。

![binary-stdout](https://images2018.cnblogs.com/blog/886021/201808/886021-20180822110524545-1308241643.png)

输出的 colse() 方法会在比特流的最后一个字节用 0 补齐，以保证和文件系统的兼容性。

这是一个数据压缩的简单例子，用三种不同方式来表示日期 12/31/1990。第一种把日期当做字符串，每位用一个字节的字符类型表示，需要 80 位。第二种用三个 int 类型，需要 96 位。第三种的编码是变长的，像月份只要 4 位就能编码，而且最后补了 3 个 0 来兼容字节流，总计 24 位。这是最粗糙的数据压缩方式。

![data-compression-example](https://images2018.cnblogs.com/blog/886021/201808/886021-20180822110539555-18616530.png)

转储（dump）表示的是比特流的一种可供人类阅读的形式，用于帮助我们在调试的时候检查比特流或者字节流的内容。下图是一些例子：BinaryDump 将比特流按 0 和 1 输出来；HexDump 将比特流组织成 8 位并用两位的 16 进制数表示；PictureDump 则将比特流变为 Picture 对象，其中白色像素表示 0，黑色像素表示 1。

![test-bitestream](https://images2018.cnblogs.com/blog/886021/201808/886021-20180822120656916-514002849.png)

最后我们需要认识到一点：通用数据压缩算法是不存在的。这其实也很好理解，要是存在这样的算法，那意味着我们可以再对压缩文件进行压缩，循环往复到文件大小为零，显然是不合理的。

## run-length Coding

## Huffman Compression

## LZW-compression