# 算法分析

## Introduction

有各种原因要求我们分析算法，像预测算法性能，比较不同算法优劣等，其中很实际的一条原因是为了避免性能错误，要对自己算法的性能有个概念。

科学方法（**scientific method**）也适用于算法分析，提供了一个预测性能和比较算法的框架：

- **Observe** 观察真实世界的某些特征
- **Hypothesize** 根据观察结果提出假设模型
- **Predict** 用模型预测未来的事件
- **Verify** 继续观察来核实预测的准确性
- **Validate** 重复直到预测和观察一致

此外还有两条原则：

- **reproduceible** 实验得是别人可以重现的
- **falsifiable** 假设可以被实验证伪

## Observations

先给出一个例子，叫 **3-sum** 问题，即给定一组数，问三数之和为零的有哪些组合，据说在计算几何中很有用。暴力求解的算法很简单，三个 for 循环。

### 3-Sum Brute-Force Algorithm

```java
public class ThreeSum {
    public static int count(int[] a) {
        int N = a.length;
        int count = 0;
        for (int i = 0; i < N; i++)
            for (int j = i + 1; j < N; j++)
                for (int k = j + 1; k < N; k++)
                    if (a[i] + a[j] + a[k] == 0)
                    count++;
        return count;
    }

    public static void main(String[] args) {
        int[] a = In.readInts(args[0]);
        StdOut.println(count(a));
    }
}
```

分析算法时的观测即是看程序的运行时间，你可以用秒表计时，或是使用 java 中计时的类。

```java
public static void main(String[] args) {
    int[] a = In.readInts(args[0]);
    Stopwatch stopwatch = new Stopwatch();
    StdOut.println(ThreeSum.conut(a));
    double time = stopwatch.elapsedTime();
}
```

运行这个程序，就可以知道上述暴力算法的运行时间。

![3-sum-brute-force-time](https://images2018.cnblogs.com/blog/886021/201805/886021-20180530170903216-489339110.png)

有了这些数据，我们可以画出运行时间和输入数据规模 N 的函数图像。

![standard-plot](https://images2018.cnblogs.com/blog/886021/201805/886021-20180530171344930-1748897699.png)

这个不好求二者关系，我们还可以画成双对数的形式。

![log-log-polt](https://images2018.cnblogs.com/blog/886021/201805/886021-20180530171408623-75590747.png)

这张图看起来好求些，但其实我们都不用画图。

![lg-ratio](https://images2018.cnblogs.com/blog/886021/201805/886021-20180530172156386-759709228.png)

每次运行将数据规模翻倍，由式子 aN^b ，前后运行时间之比即为 2^b ，再取 lg ，就可大致知道 b 的级别。知道 b 再随便带入一点计算，即可得到 a 。求出 a 和 b 就可以用输入数据规模 N 来预测运行时间了。

b 由算法和输入数据决定，a 则还会受到软硬件等各方面的影响，所以我们很难得到准确的测量。但比起其他科学，我们的实验成本很低，可以进行大量的实验。

## Mathematical Models

## Order-of-Growth Classifications

## Theory of Algorithms

## Memory