# 算法分析

## Introduction

有各种原因要求我们分析算法，像预测算法性能，比较不同算法优劣等，其中很实际的一条原因是为了避免性能错误，要对自己算法的性能有个概念。

科学方法（**scientific method**）也适用于算法分析，它提供了一个预测性能和比较算法的框架：

- **Observe** 观察真实世界的某些特征
- **Hypothesize** 根据观察结果提出假设模型
- **Predict** 用模型预测未来的事件
- **Verify** 继续观察来核实预测的准确性
- **Validate** 重复直到预测和观察一致

此外还有两条原则：

- **reproduceible** 实验得是别人可以重现的
- **falsifiable** 假设可以被实验证伪

## Observations

先给出一个例子，叫 **3-sum** 问题，即给定一组数，问三数之和为零的有哪些组合，据说在计算几何中很有用。暴力求解的算法很简单，三个 for 循环。

### 3-Sum Brute-Force Algorithm

```java
public class ThreeSum {
    public static int count(int[] a) {
        int N = a.length;
        int count = 0;
        for (int i = 0; i < N; i++)
            for (int j = i + 1; j < N; j++)
                for (int k = j + 1; k < N; k++)
                    if (a[i] + a[j] + a[k] == 0)
                    count++;
        return count;
    }

    public static void main(String[] args) {
        int[] a = In.readInts(args[0]);
        StdOut.println(count(a));
    }
}
```

分析算法时的观测即是看程序的运行时间，你可以用秒表计时，或是使用 java 中计时的类。

```java
public static void main(String[] args) {
    int[] a = In.readInts(args[0]);
    Stopwatch stopwatch = new Stopwatch();
    StdOut.println(ThreeSum.conut(a));
    double time = stopwatch.elapsedTime();
}
```

运行这个程序，就可以知道上述暴力算法的运行时间。

![3-sum-brute-force-time](https://images2018.cnblogs.com/blog/886021/201805/886021-20180530170903216-489339110.png)

有了这些数据，我们可以画出运行时间和输入数据规模 N 的函数图像。

![standard-plot](https://images2018.cnblogs.com/blog/886021/201805/886021-20180530171344930-1748897699.png)

这个不好求二者关系，我们还可以画成双对数的形式。

![log-log-polt](https://images2018.cnblogs.com/blog/886021/201805/886021-20180530171408623-75590747.png)

这张图看起来好求些，但其实我们都不用画图。

![lg-ratio](https://images2018.cnblogs.com/blog/886021/201805/886021-20180530172156386-759709228.png)

每次运行将数据规模翻倍，由式子 $aN^{b}$ ，前后运行时间之比即为 $2^{b}$ ，再取 $lg$ ，就可大致知道 b 的级别。知道 b 再随便带入一点计算，即可得到 a 。求出 a 和 b 就可以用输入数据规模 N 来预测运行时间了。

b 由算法和输入数据决定，a 则还会受到软硬件等各方面的影响，所以我们很难得到准确的测量。但比起其他科学，我们的实验成本很低，可以进行大量的实验。

## Mathematical Models

原则上我们仍然可能构造出一个数学模型来描述任意程序的运行时间，总运行时间即为每个操作的耗时和频率乘积的总和。耗时和计算机硬件，Java 编译器，操作系统等有关，后者则取决于算法和输入。

但我们不是理论家，不需要这么精确，可以简化计算，粗略的估计依然很有用。

### Simplification 1: Cost Model

成本模型，用开销最大的或执行次数最多的基本操作来估计运行时间，这里选取访问数组这个操作。

![array-access](https://images2018.cnblogs.com/blog/886021/201805/886021-20180530233631787-1659911348.png)

### Simplification 2: Tilde Notation

忽略式子中的低阶项，当 N 很大的时候，低阶项并没有什么影响，N 很小时的情况我们并不关心。

![tilde-Notation](https://images2018.cnblogs.com/blog/886021/201805/886021-20180530233648757-1790556000.png)

f(N)~g(N) 代表着 $\lim\limits_{x \rightarrow 0} \frac{f(N)}{g(N)}$ （附：[LaTeX](http://www.cnblogs.com/schaepher/p/5875185.html)）。

## Order-of-Growth Classifications

增长数量级的分类，我们在实现算法时使用了几种结构性的原语，像循环，嵌套语句，所以成本增长的数量级一般都是问题规模 N 的若干函数之一。

![order-of-growth-table](https://images2018.cnblogs.com/blog/886021/201806/886021-20180601160010525-427986291.png)

从双对数图更能说明平方级别和立方级别的算法对于大规模的问题是不可用的。

![order-of-growth-graph](https://images2018.cnblogs.com/blog/886021/201806/886021-20180601160022017-627166751.png)

因此，我们自然希望为各种基础问题找到对数级别、线性级别或是线性对数级别的算法。

上面提到的 **3-Sum** 问题，暴力求解是立方级别，我们可以用二分查找对其做些改进。

### Binary Search

```java
public static int binarySearch(int[] a, int key) {
    int lo = 0, hi = a.length-1;
    while (lo <= hi) {
        int mid = lo + (hi - lo) / 2;
        if (key < a[mid]) hi = mid - 1;
        else if (key > a[mid]) lo = mid + 1;
        else return mid;
    }
    return -1;
}
```

二分查找在大小为 N 的有序数组中最多只要进行 $1 + lgN$ 次比较，也就是对数级别。

可以递推地证明这一结论。

![T(N)](https://images2018.cnblogs.com/blog/886021/201806/886021-20180601163303382-352957895.png)

于是我们第一步要对数组进行排序，随便来个平方级别的插入排序，然后对数组中每一对 a[i] 和 a[j] ，二分查找 -(a[i] + a[j]) ，这是 $N^{2}logN$ 级别，总的来说这算法是 $N^{2}logN$ 级别的。

![three-sum-deluxe](https://images2018.cnblogs.com/blog/886021/201806/886021-20180601165147962-985422205.png)

可以看出这样也比原来立方的级别好很多，更好的数量级，更好的性能表现。

## Theory of Algorithms

## Memory