# 哈希表

红黑树实现的符号表可以保证对数级别的性能，但我们可以做得更好。哈希表实现的符号表提供了新的数据访问方式，插入和搜索操作可以在常数时间内完成（不支持和顺序有关的操作）。所以，在很多情况下的简单符号表，用哈希表实现是最好的选择。

## hash functions

哈希函数把键转化成数组索引，然后键对应的值就放在数组那个位置，以此来快速插入和查找数据。为此我们需要设计哈希函数，考虑怎么处理可能发生的碰撞（不同键生成相同索引）。

哈希表是算法在时间和空间上作出权衡的经典例子。如果没有内容限制，我们可以直接将键作为（可能是一个超大的）数组的索引，那么所有查找操作只需要访问内存一次即可完成。但这种理想情况不会经常出现，因为当键很多时需要的内存太多。另一方面，如果没有时间限制，我们可以使用无序数组并进行顺序查找，这样就只需要很少的内存。而哈希表则使用了适度的空间和时间并在这两个极端之间找到了一种平衡。

对于哈希函数，我们希望能够易于计算且能够均匀分布所有的键，严格来说，对于每种类型我们都需要一个与之对应的哈希函数。于是，Java 令所有数据类型都继承了一个能够返回一个 32 位整数的 hashCode() 方法。如果 a.equals(b) 返回 true，那么 a.hashCode() 的返回值必然和 b.hashCode() 的返回值相同。如果两个对象的 hashCode() 方法的返回值不同，那么我们就知道这两个对象是不同的。但如果两个对象的 hashCode() 方法相同，这两个对象也有可能不同。默认哈希函数会返回对象的内存地址，但这只适用于很少的情况。Java 为很多常用的数据类型重写了 hashCode() 方法（包括 String、Integer、Double、File 和 URL）。

## separate chaining

## linear probing

## context