# 平衡搜索树

前面介绍的二叉搜索树在最快情况下的性能还是很糟糕，而且我们不能控制操作的顺序，有时根本就不是随机的，我们希望找到有更好性能保证的算法。

## 2-3 search trees

于是先来了解下 2-3 查找树，它可以保证树的平衡性，维护树高在 lgN 级别。这里的 2，3 指的是孩子的数目，图例：

![23tree-anatomy]()

有两个孩子的节点和二叉搜索树一样，节点里有一个键，且大于左子树的键并小于右子树的键。三个孩子的节点里则有两个键，中间孩子的键的大小介于这两个键之间，左右子树一样。

### search

查找和二叉查找树一样，虽然现在有的点有两个键，那也没什么关系。

查找图例：

![23tree-search]()

### insert

插入操作算是比较关键，解释了为什么可以保证树的平衡性，下面是各种情况的示意：

![23tree-insert]()

插入 2-node 时，直接插入把这个节点变成 3-node 即可，上面也没有列出来。插入 3-node 时比较复杂，要先暂时变成 4-node，然后再把三个键中间的键向父母节点转移，问题就又转移到了父母节点上。不难发现，只有在插入路径上全部都是 3-node 时，插入才会让树的高度加一（一路到根节点变成上图情况一）。

而且，上面的操作找到位置后只是改变链接的局部变换，没有数据转移什么的，时间很快，效率挺高。最坏情况下都是 2-node，树高为 lgN，最好情况下都是 3-node，树高为 $log_{3}N \approx .631 lgN$，反正树高是对数级别，也就保证了查找和插入对数级别的性能。

但是吧，谈到实现，直接实现太复杂，有好多不同类型的节点，还要进行类型转换，而且需要处理的情况也有很多。实现这些不仅需要大量的代码，而且它们产生的额外开销可能会使算法比标准的二叉查找树更慢。我们希望维护树的平衡，同时也希望保障所需的代码能够越少越好。于是乎，红黑树出现啦！

## red-black BSTs

## B-trees